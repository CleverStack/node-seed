var BaseService = require( './BaseService' )
  , Q = require( 'q' )
  , Sequelize = require( 'sequelize' )
  , sendgrid = require( 'utils' ).sendgrid
  , ejsFileRender = require( 'utils' ).ejsfilerender
  , shortid = require( 'shortid' )
  , EmailService = null;

module.exports = function ( db,
                            EmailModel,
                            EmailAttachmentModel,
                            ProspectModel,
                            EmailReplyModel,
                            UserModel,
                            JobModel,
                            EmailUserModel,
                            EmailTemplateService,
                            ProspectSurveyService,
                            config ) {

    var mailer = sendgrid( config.sendgrid )
      , bakeTemplate = ejsFileRender();

    if ( EmailService && EmailService.instance ) {
        return EmailService.instance;
    }

    EmailService = BaseService.extend( {

        formatReplyAddress: function ( emailToken ) {
            var addr = ''
              , envName = '';

            envName = ( config.environmentName == 'DEV' )
                ? 'dev'
                : ( config.environmentName == 'PROD' )
                    ? 'prod'
                    : 'stage';

            addr = ( envName != 'prod' )
                ? 'reply_' + emailToken + '@' + envName + '.bolthr.clevertech.biz'
                : 'reply_' + emailToken + '@app-mail.bolthr.com';

            return addr;
        },

        formatData: function ( data, operation ) {
            var o = { email: {}, prospect: {}, usersCC: [], usersBCC: [], attachments: [], sender: {} };
            var emailURL = '';

            // o['account'] = {};
            // o['account']['logo'] = data.accLogo;
            // o['account']['name'] = data.accName;

            //Email Object
            o.email.subject = data.subject || null;
            o.email.body = data.body || null;
            o.email.token = data.userId + data.to.id + shortid.seed( 10000 ).generate();
            o.email.UserId = data.userId;
            o.email.AccountId = data.accId;
            o.email.ProspectId = data.to.id;
            o.email.JobId = data.JobId || null;

            o.hasTemplate = (/false|true/.test( data.hasTemplate )) ? data.hasTemplate : true;

            emailURL = this.formatReplyAddress( o.email.token );

            // o.sender.fullName = data.userFirstName + ' ' + data.userLastName;
            // o.sender.email    = emailURL;

            //EmailProspect object
            // o.prospect  = data.to;

            //EmailUsers Object
            o.usersCC = ( data.cc && data.cc.length ) ? data.cc : [];
            o.usersBCC = ( data.bcc && data.bcc.length) ? data.bcc : [];

            var usersCC = ( data.cc && data.cc.length ) ? data.cc.map( function ( x ) { return x.email } ) : [];
            var usersBCC = ( data.bcc && data.bcc.length) ? data.bcc.map( function ( x ) { return x.email } ) : [];

            //Dump email dependency data
            var dataDump = {
                companyLogo: data.accLogo,
                companyName: data.accName,
                fromName: data.userFirstName + ' ' + data.userLastName,
                fromMail: emailURL,
                toMail: data.to.email,
                usersCC: usersCC,
                usersBCC: usersBCC,
                tplName: 'default',
                tplTitle: data.subject || 'BoltHR: Autogenerated Notification',
                hasTemplate: (/false|true/.test( data.hasTemplate )) ? data.hasTemplate : true
            };

            o['email']['dump'] = JSON.stringify( dataDump );

            //EmailAttachements Object
            o.attachments = ( data.attachments && data.attachments.length ) ? data.attachments : [];

            o.survey = ( data.survey ) ? data.survey : null;

            if ( operation === 'create' ) {
                o.email.UserId = data.userId;
                o.email.EmailTemplateId = data.EmailTemplateId || null
                o.email.sentAttemps = 0;
                o.email.isDelivered = false;
                o.email.isOpened = false;
                o.email.id = null;
            }

            return o;
        },
        //TODO: change sentAttempts and isDelivered values when we move notification mail into background tasks
        formatRepliedData: function ( data ) {
            var replyAddr = this.formatReplyAddress( data['emailToken'] );

            var o = {
                id: null,
                reply: data.reply,
                EmailId: data.emailId,
                token: data.emailId + '_' + shortid.seed( 10000 ).generate(),
                sentAttemps: 1,
                isDelivered: true,
                isOpened: false
            };

            var t = {
                subject: data.subject,
                html: data.replyHTML,
                replyAddress: replyAddr
            };

            if ( data.from.indexOf( data[ 'userEmail' ] ) != -1 ) {

                o['from'] = data.userEmail;
                t['fromname'] = null;

                o['to'] = data.prospectEmail;
                t['toname'] = data.prospectName;

            } else if ( data.from.indexOf( data[ 'prospectEmail' ] ) != -1 ) {

                o['from'] = data.prospectEmail;
                t['fromname'] = data.prospectName;

                o['to'] = data.userEmail;
                t['toname'] = null;

            } else {

                o['from'] = t['fromname'] = o['to'] = t['toname'] = null;

            }

            o['dump'] = JSON.stringify( t );

            return o;
        },

        listEmails: function ( userId, emailId ) {
            var deferred = Q.defer();

            this
                .find( { where: { UserId: userId }, include: [ EmailAttachmentModel, ProspectModel, EmailReplyModel ] } )
                .then( deferred.resolve )
                .fail( deferred.reject );

            return deferred.promise;
        },

        getEmailById: function ( userId, emailId ) {
            var deferred = Q.defer()
                , service = this
                , chainer = new Sequelize.Utils.QueryChainer();

            chainer.add(
                EmailModel.find( {
                    where: { id: emailId, UserId: userId, 'deletedAt': null }, include: [ EmailAttachmentModel, ProspectModel, EmailReplyModel ]
                } )
            );

            chainer.add(
                EmailUserModel.find( {
                    where: { EmailId: emailId, 'deletedAt': null }, include: [ UserModel ]
                } )
            );

            chainer
                .run()
                .success( function ( results ) {

                    if ( !results[0] ) {
                        deferred.resolve( {statuscode: '403', message: 'invalid'} );
                        return;
                    }

                    var emailJson = JSON.parse( JSON.stringify( results[ 0 ] ) );
                    var emailUsers = results[ 1 ];

                    emailJson['users'] = emailUsers;
                    deferred.resolve( emailJson );

                } )
                .error( deferred.reject );

            return deferred.promise;
        },

        handleEmailCreation: function ( data ) {
            var promises = []
              , service = this;

            data.forEach( function ( item ) {
                promises.push( service.processEmailCreation( item ) );
            } );

            return Q.all( promises );
        },

        processEmailCreation: function ( emailItem ) {
            var deferred = Q.defer()
              , service = this
              , fData = this.formatData( emailItem, 'create' );

            service
                .create( fData.email )
                .then( function ( savedEmail ) {
                    console.log( 'Email saved!' );

                    service
                        .saveEmailAssociation( savedEmail, fData )
                        .then( function () {
                            console.log( 'Email assoc saved!' );

                            if ( !fData.survey ) {
                                deferred.resolve( {statucode: 200, message: "email has been sent"} );
                                return;
                            }

                            service
                                .handleProspectSurveyCreation( fData.email, fData.survey )
                                .then( deferred.resolve )
                                .fail( deferred.reject );

                        } )
                        .then( deferred.resolve )
                        .fail( deferred.reject );
                } )
                .fail( deferred.reject );

            return deferred.promise;
        },

        handleProspectSurveyCreation: function ( email, survey ) {
            var deferred = Q.defer();

            ProspectSurveyService
                .createProspectSurvey( {
                    pointsAwarded: survey.pointsPossible,
                    SurveyId: survey.id,
                    accId: email.AccountId,
                    ProspectId: email.ProspectId,
                    token: survey.token
                } )
                .then( deferred.resolve )
                .fail( deferred.reject );

            return deferred.promise;
        },

        saveEmailAssociation: function ( savedEmail, fData ) {
            var deferred = Q.defer()
                , chainer = new Sequelize.Utils.QueryChainer();

            //USERS: CC
            if ( fData.usersCC.length ) {
                var l = fData.usersCC.length, item, cc = [];
                while ( l-- ) {
                    item = fData.usersCC[l];
                    cc.push( {
                        EmailId: savedEmail.id, UserId: item.id, status: 'cc'
                    } );
                }

                chainer.add( EmailUserModel.bulkCreate( cc ) );
            }

            //USERS: BCC
            if ( fData.usersBCC.length ) {
                var l = fData.usersBCC.length, itm, bcc = [];

                while ( l-- ) {
                    itm = fData.usersBCC[l];
                    bcc.push( {
                        EmailId: savedEmail.id, UserId: itm.id, status: 'bcc'
                    } );
                }

                chainer.add( EmailUserModel.bulkCreate( bcc ) );
            }

            //Attachments
            if ( fData.attachments.length ) {
                var l = fData.attachments.length, attch, emailDocs = [];

                while ( l-- ) {
                    attch = fData.attachments[l];
                    emailDocs.push( {
                        id: null, filePath: attch.filePath, fileName: attch.fileName, mimeType: attch.mimeType, EmailId: savedEmail.id
                    } );
                }

                chainer.add( EmailAttachmentModel.bulkCreate( emailDocs ) );
            }

            chainer
                .run()
                .success( function ( result ) {
                    //console.log("RESULT:", JSON.parse(JSON.stringify(result)) );
                    deferred.resolve();
                } )
                .error( function ( err ) {
                    console.log( err );
                    deferred.reject( err );
                } );

            return deferred.promise;
        },

        renderTemplate: function ( data ) {
            var deferred = Q.defer()
                , email = data['email']
                , user = data['user'] || null
                , tplName = data['tplName'] || null
                , tpl = {};

            tpl['tplName'] = tplName || 'default';
            tpl['tplTitle'] = email.subject || 'BoltHR: Autogenerated Notification';
            tpl['companyName'] = ( email.dump.fromCompanyName ) ? email.dump.fromCompanyName : 'BoltHR';
            tpl['companyLogo'] = ( email.dump.fromCompanyLogo ) ? email.dump.fromCompanyLogo : 'http://app.bolthr.com/images/logo.png';

            //Text has already being parsed from frontend
            if ( !email.EmailTemplateId ) {
                tpl['strHTML'] = email.body;

                bakeTemplate( tpl )
                    .then( deferred.resolve )
                    .fail( deferred.reject );

            } else {

                EmailTemplateService
                    .getPlaceholderData( {
                        accId: email.AccountId, ProspectId: email.ProspectId, EmailTemplateId: email.EmailTemplateId, JobId: null
                    } )
                    .then( function ( emailTemplate ) {
                        return EmailTemplateService.processTemplateIntrpolation( user, emailTemplate );
                    } )
                    .then( function ( html ) {
                        tpl['strHTML'] = html;

                        return bakeTemplate( tpl );
                    } )
                    .then( deferred.resolve )
                    .fail( deferred.reject );
            }

            return deferred.promise;
        },

        sendEmail: function ( email, html ) {
            var deferred = Q.defer()
                , fromMail = 'no-reply@app.bolthr.com'
                , fromName = 'BoltHR'
                , subject = email.subject || 'BoltHR: Notification'
                , emailId = email.id
                , payload = {};

            if ( email.dump.fromCompanyName ) {
                fromName = email.dump.fromName;
                fromMail = email.dump.fromMail;
            }

            payload = {
                to: [ email.dump.toMail ],
                bcc: email.dump.usersBCC,
                subject: subject,
                html: html,
                from: fromMail,
                fromname: fromName,
                emailId: emailId
            };

            if ( email.dump.usersCC && email.dump.usersCC.length ) {

                email.dump.usersCC.forEach( function ( userEmail ) {
                    payload.to.push( userEmail );
                } );

            }

            mailer( payload )
                .then( deferred.resolve )
                .fail( deferred.reject );

            return deferred.promise;
        },

        processMailReply: function ( data ) {
            var deferred = Q.defer()
              , service = this;

            this
                .findOne( { where: { token: data.replyMailHash }, include: [ UserModel, ProspectModel ] } )
                .then( function ( email ) {

                    if ( !email || !email.id ) {
                        console.log( "\n\n----- EMAIL REPLY TOKEN DOES NOT EXISTS ------\n" );
                        deferred.resolve();
                        return;
                    }

                    console.log( "\n\n----- EMAIL REPLY TOKEN EXISTS ------\n" );

                    data['emailId'] = email.id;
                    data['emailToken'] = email.token;
                    data['userEmail'] = email.user.email;
                    data['userName'] = email.user.firstname + ' ' + email.user.lastname;
                    data['prospectEmail'] = email.prospect.email;
                    data['prospectName'] = email.prospect.firstName + ' ' + email.prospect.lastName;

                    service
                        .saveMailReply( data )
                        .then( deferred.resolve )
                        .fail( deferred.reject );

                } )
                .fail( deferred.reject );

            return deferred.promise;
        },

        saveMailReply: function ( data ) {
            var deferred = Q.defer()
                , replyData = this.formatRepliedData( data );

            EmailReplyModel
                .create( replyData )
                .success( deferred.resolve )
                .error( deferred.reject );

            return deferred.promise;
        },

        //TODO: Move this function into Background Tasks
        processMailReplyNotification: function ( savedReply ) {
            var deferred = Q.defer()
              , mail = JSON.parse( JSON.stringify( savedReply ) )
              , payload = { };

            payload[ 'from' ] = mail.dump.replyAddress;
            payload[ 'fromname' ] = mail.dump.fromname;
            payload[ 'to' ] = [ mail.to ];
            payload[ 'toname' ] = mail.dump.toname;

            payload[ 'subject' ] = mail.dump.subject;
            payload[ 'text' ] = mail.reply;
            payload[ 'html' ] = mail.dump.html;

            mailer( payload )
                .then( deferred.resolve )
                .fail( deferred.resolve );

            return deferred.promise;
        },

        processMailEvents: function ( evns ) {
            var deferred = Q.defer()
                , item = null
                , chainer = new Sequelize.Utils.QueryChainer();

            while ( item = evns.pop() ) {
                console.log( "\nUPDATING: ", item.email_id );
                chainer.add( EmailModel.update( { isOpened: true }, { id: item.email_id, 'deletedAt': null} ) );
            }

            chainer
                .run()
                .success( function () {
                    deferred.resolve( {statuscode: 200, message: 'ok'} );
                } )
                .error( deferred.reject );

            return deferred.promise;
        }

    } );

    EmailService.instance = new EmailService( db );
    EmailService.Model = EmailModel;
console.log('-----------------------')
    return EmailService.instance;
};